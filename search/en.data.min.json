[{"id":0,"href":"/istio/readme/","title":"Readme","parent":"Istio","content":"Table of Contents\n什么是Service Mesh Service Mesh的特点 什么是Istio 为什么需要Istio Istio的功能 Istio的架构 如何使用Istio 什么是Service Mesh 服务网格（Service Mesh）是处理服务间通信的基础设施层。它负责构成现代云原生应用程序的复杂服务拓扑来可靠地交付请求。在实践中，Service Mesh 通常以轻量级网络代理阵列的形式实现，这些代理与应用程序代码部署在一起，对应用程序来说无需感知代理的存在。\n维基百科解释如下：\nIn software architecture, a service mesh is a dedicated infrastructure layer for facilitating service-to-service communications between services or microservices, using a proxy.\nService Mesh的特点 Service Mesh 有如下几个特点：\n应用程序间通信的中间层 轻量级网络代理 应用程序无感知 解耦应用程序的重试/超时、监控、追踪和服务发现 目前两款流行的 Service Mesh 开源软件 Istio 和 Linkerd 都可以直接在 Kubernetes 中集成，其中 Linkerd 已经成为 CNCF 中的项目。\n什么是Istio Istio 是一种服务网格工具，是一种现代化的服务网络层，它提供了一种透明、独立于语言的方法，以灵活且轻松地实现应用网络功能自动化。它是一种管理构成云原生应用的不同微服务的常用解决方案。Istio 服务网格还支持这些微服务彼此之间的通信和数据共享方式。\n为什么需要Istio Service Mesh 并没有给我们带来新功能，它是用于解决其他工具已经解决过的问题，只不过这次是在以 Kubernetes 为基础的云原生生态环境下的实现。\n在传统的 MVC 三层 Web 应用程序架构下，服务之间的通讯并不复杂，在应用程序内部自己管理即可，但是在现今的复杂的大型网站情况下，单体应用被分解为众多的微服务，服务之间的依赖和通讯十分复杂。\n在 Cloud Native 架构下，容器的使用赋予了异构应用程序更多的可能性，Kubernetes 增强了应用的横向扩容能力，用户可以快速的编排出复杂环境、复杂依赖关系的应用程序，同时开发者又无须过分关心应用程序的监控、扩展性、服务发现和分布式追踪这些繁琐的事情，进而专注于程序开发，赋予开发者更多的创造性。\nIstio的功能 Istio 提供一种简单的方式来为已部署的服务建立网络，该网络具有负载均衡、服务间认证、监控等功能，只需要对服务的代码进行一点或不需要做任何改动。想要让服务支持 Istio，只需要在您的环境中部署一个特殊的 sidecar 代理，使用 Istio 控制平面功能配置和管理代理，拦截微服务之间的所有网络通信：\nHTTP、gRPC、WebSocket 和 TCP 流量的自动负载均衡。 通过丰富的路由规则、重试、故障转移和故障注入，可以对流量行为进行细粒度控制。 可插入的策略层和配置 API，支持访问控制、速率限制和配额。 对出入集群入口和出口中所有流量的自动度量指标、日志记录和追踪。 通过强大的基于身份的验证和授权，在集群中实现安全的服务间通信。 Istio的架构 如何使用Istio 请查看具体组件分析\nKiali VirtualService DestinationRule ServiceEntry Gateway Sidecar 参考： 实验参考链接\nhttps://jimmysong.io/blog/what-is-a-service-mesh/\n","description":"Table of Contents\n什么是Service Mesh Service Mesh的特点 什么是Istio 为什么需要Istio Istio的功能 Istio的架构 如何使用Istio 什么是Service Mesh 服务网格（Service Mesh）是处理服务间通信的基础设施层。它负责构成现代云原生应用程序的复杂服务拓扑来可靠地交付请求。在实践中，Service Mesh 通常以轻量级网络代理阵列的形式实现，这些代理与应用程序代码部署在一起，对应用程序来说无需感知代理的存在。\n维基百科解释如下：\nIn software architecture, a service mesh is a dedicated infrastructure layer for facilitating service-to-service communications between services or microservices, using a proxy.\nService Mesh的特点 Service Mesh 有如下几个特点：\n应用程序间通信的中间层 轻量级网络代理 应用程序无感知 解耦应用程序的重试/超时、监控、追踪和服务发现 目前两款流行的 Service Mesh 开源软件 Istio 和 Linkerd 都可以直接在 Kubernetes 中集成，其中 Linkerd 已经成为 CNCF 中的项目。\n什么是Istio Istio 是一种服务网格工具，是一种现代化的服务网络层，它提供了一种透明、独立于语言的方法，以灵活且轻松地实现应用网络功能自动化。它是一种管理构成云原生应用的不同微服务的常用解决方案。Istio 服务网格还支持这些微服务彼此之间的通信和数据共享方式。\n为什么需要Istio Service Mesh 并没有给我们带来新功能，它是用于解决其他工具已经解决过的问题，只不过这次是在以 Kubernetes 为基础的云原生生态环境下的实现。"},{"id":1,"href":"/istio/install/","title":"Install","parent":"Istio","content":"Table of Contents\ninstall istio and kiali install istio and kiali 根据官方文档下载istio工具，这里我使用的istio 1.15.0， 所以工具名称改为了istioctl_1_15_0\nistioctl_1_15_0 install --set profile=demo --set meshConfig.outboundTrafficPolicy.mode=ALLOW_ANY kubectl apply -f https://raw.githubusercontent.com/istio/istio/master/samples/addons/kiali.yaml kubectl apply -f https://raw.githubusercontent.com/istio/istio/master/samples/addons/prometheus.yaml istioctl_1_15_0 dashboard kiali ","description":"Table of Contents\ninstall istio and kiali install istio and kiali 根据官方文档下载istio工具，这里我使用的istio 1.15.0， 所以工具名称改为了istioctl_1_15_0\nistioctl_1_15_0 install --set profile=demo --set meshConfig.outboundTrafficPolicy.mode=ALLOW_ANY kubectl apply -f https://raw.githubusercontent.com/istio/istio/master/samples/addons/kiali.yaml kubectl apply -f https://raw.githubusercontent.com/istio/istio/master/samples/addons/prometheus.yaml istioctl_1_15_0 dashboard kiali "},{"id":2,"href":"/istio/virtualservice/","title":"Virtualservice","parent":"Istio","content":"Table of Contents\nvirtualservice virtualservice apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: reviews spec: hosts: - reviews http: - match: - headers: end-user: exact: jason #规则限制为仅匹配v2 DR，且请求包含值为 jason 的end-user自定义标头。 route: - destination: host: reviews subset: v2 - route: - destination: host: reviews subset: v3 ","description":"Table of Contents\nvirtualservice virtualservice apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: reviews spec: hosts: - reviews http: - match: - headers: end-user: exact: jason #规则限制为仅匹配v2 DR，且请求包含值为 jason 的end-user自定义标头。 route: - destination: host: reviews subset: v2 - route: - destination: host: reviews subset: v3 "},{"id":3,"href":"/istio/destinationrule/","title":"Destinationrule","parent":"Istio","content":"Table of Contents\ndestinationrule destinationrule apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: my-destination-rule spec: host: my-svc trafficPolicy: loadBalancer: simple: RANDOM subsets: - name: v1 labels: version: v1 - name: v2 labels: version: v2 trafficPolicy: loadBalancer: simple: ROUND_ROBIN - name: v3 labels: version: v3 ","description":"Table of Contents\ndestinationrule destinationrule apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: my-destination-rule spec: host: my-svc trafficPolicy: loadBalancer: simple: RANDOM subsets: - name: v1 labels: version: v1 - name: v2 labels: version: v2 trafficPolicy: loadBalancer: simple: ROUND_ROBIN - name: v3 labels: version: v3 "},{"id":4,"href":"/istio/serviceentry/","title":"Serviceentry","parent":"Istio","content":"Table of Contents\nserviceentry serviceentry apiVersion: networking.istio.io/v1beta1 kind: ServiceEntry metadata: name: svc-entry namespace: test spec: hosts: - \u0026#34;www.baidu.com\u0026#34; ports: - number: 80 name: http protocol: HTTP - number: 443 name: https protocol: HTTPS location: MESH_EXTERNAL resolution: DNS serviceEntry服务发现模式说明\nresolution的定义, 它用来定义服务发现的模式，它有三种值，分别为 DNS、STATIC 和 NONE\nDNS 模式:，当 pod 里的应用发送 www.baidu.com 请求的时候，会使用dns来查找域名指定的服务器，在这种情况下，就和我们平时打开一个网站逻辑完全一样，所以肯定是可以正常访问的。\nSTATIC 模式: 当 pod 里的应用发送 www.baidu.com 请求的时候，会向请求转到 endpoints 字段指定的IP 服务器，我们这里指向的是一个内网IP地址，所以无法正常响应。对于endpoints字段可以多个，并允许对其根据 LB 权重设置, 有兴趣的可以了解下 https://istio.io/latest/zh/docs/reference/config/networking/service-entry/#ServiceEntry-Endpoint\nNONE 模式: 要小心使用，在这种模式下，如果未指定任何IP地址的话，则默认将允许发送到任意IP上。\n","description":"Table of Contents\nserviceentry serviceentry apiVersion: networking.istio.io/v1beta1 kind: ServiceEntry metadata: name: svc-entry namespace: test spec: hosts: - \u0026#34;www.baidu.com\u0026#34; ports: - number: 80 name: http protocol: HTTP - number: 443 name: https protocol: HTTPS location: MESH_EXTERNAL resolution: DNS serviceEntry服务发现模式说明\nresolution的定义, 它用来定义服务发现的模式，它有三种值，分别为 DNS、STATIC 和 NONE\nDNS 模式:，当 pod 里的应用发送 www.baidu.com 请求的时候，会使用dns来查找域名指定的服务器，在这种情况下，就和我们平时打开一个网站逻辑完全一样，所以肯定是可以正常访问的。\nSTATIC 模式: 当 pod 里的应用发送 www.baidu.com 请求的时候，会向请求转到 endpoints 字段指定的IP 服务器，我们这里指向的是一个内网IP地址，所以无法正常响应。对于endpoints字段可以多个，并允许对其根据 LB 权重设置, 有兴趣的可以了解下 https://istio.io/latest/zh/docs/reference/config/networking/service-entry/#ServiceEntry-Endpoint\nNONE 模式: 要小心使用，在这种模式下，如果未指定任何IP地址的话，则默认将允许发送到任意IP上。"},{"id":5,"href":"/istio/gateway/","title":"Gateway","parent":"Istio","content":"Table of Contents\ngateway gateway apiVersion: networking.istio.io/v1beta1 kind: Gateway metadata: annotations: labels: istio: ingressgateway name: demo-gateway namespace: istio-system spec: selector: istio: ingressgateway servers: - hosts: - qwe.asd.com port: name: http-digital number: 80 protocol: HTTP ","description":"Table of Contents\ngateway gateway apiVersion: networking.istio.io/v1beta1 kind: Gateway metadata: annotations: labels: istio: ingressgateway name: demo-gateway namespace: istio-system spec: selector: istio: ingressgateway servers: - hosts: - qwe.asd.com port: name: http-digital number: 80 protocol: HTTP "},{"id":6,"href":"/istio/sidecar/","title":"Sidecar","parent":"Istio","content":"Table of Contents\nsidercar Sidecar 注入实例分析 istio-init istio-proxy Istio 如何实现自动注入Sidercar 附 iptables sidercar Sidecar 注入实例分析 istio-init：用于给 Sidecar 容器即 Envoy 代理做初始化，设置 iptables 端口转发 istio-proxy：Envoy 代理容器，运行 Envoy 代理 istio-init # istio-init container yaml initContainers: - name: istio-init image: docker.io/istio/proxyv2:1.13.1 args: - istio-iptables - \u0026#39;-p\u0026#39; - \u0026#39;15001\u0026#39; - \u0026#39;-z\u0026#39; - \u0026#39;15006\u0026#39; - \u0026#39;-u\u0026#39; - \u0026#39;1337\u0026#39; - \u0026#39;-m\u0026#39; - REDIRECT - \u0026#39;-i\u0026#39; - \u0026#39;*\u0026#39; - \u0026#39;-x\u0026#39; - \u0026#39;\u0026#39; - \u0026#39;-b\u0026#39; - \u0026#39;*\u0026#39; - \u0026#39;-d\u0026#39; - 15090,15021,15020 该容器存在的意义就是让 Envoy 代理可以拦截所有的进出 Pod 的流量，即将入站流量重定向到 Sidecar，再拦截应用容器的出站流量经过 Sidecar 处理后再出站。\n/usr/local/bin/istio-iptables -p 15001 -z 15006 -u 1337 -m REDIRECT -i \u0026#39;*\u0026#39; -x \u0026#34;\u0026#34; -b * -d \u0026#34;15090,15201,15020\u0026#34; 命令解析， 这条启动命令的作用是：\n将应用容器的所有流量都转发到 Envoy 的 15006 端口。 使用 istio-proxy 用户身份运行， UID 为 1337，即 Envoy 所处的用户空间，这也是 istio-proxy 容器默认使用的用户，见 YAML 配置中的 runAsUser 字段。 使用默认的 REDIRECT 模式来重定向流量。 将所有出站流量都重定向到 Envoy 代理。 将除了 15090、15201、15020 端口以外的所有端口的流量重定向到 Envoy 代理。 istio-proxy 命令行查看 docker inspect \u0026lt;ContainerID\u0026gt; | grep Pid nsenter -t6967 -n iptables -t nat -L -v Iptables 规则解读 # 查看 NAT 表中规则配置的详细信息 $ iptables -t nat -L -v # PREROUTING 链：用于目标地址转换（DNAT），将所有入站 TCP 流量跳转到 ISTIO_INBOUND 链上 Chain PREROUTING (policy ACCEPT 27805 packets, 1668K bytes) pkts bytes target prot opt in out source destination 27805 1668K ISTIO_INBOUND tcp -- any any anywhere anywhere # INPUT 链：处理输入数据包，非 TCP 流量将继续 OUTPUT 链 Chain INPUT (policy ACCEPT 27805 packets, 1668K bytes) pkts bytes target prot opt in out source destination # OUTPUT 链：将所有出站数据包跳转到 ISTIO_OUTPUT 链上 Chain OUTPUT (policy ACCEPT 2106 packets, 194K bytes) pkts bytes target prot opt in out source destination 50 3000 ISTIO_OUTPUT tcp -- any any anywhere anywhere # POSTROUTING 链：所有数据包流出网卡时都要先进入POSTROUTING 链，内核根据数据包目的地判断是否需要转发出去，我们看到此处未做任何处理 Chain POSTROUTING (policy ACCEPT 2106 packets, 194K bytes) pkts bytes target prot opt in out source destination # ISTIO_INBOUND 链：将所有目的地为 9080 端口的入站流量重定向到 ISTIO_IN_REDIRECT 链上 Chain ISTIO_INBOUND (1 references) pkts bytes target prot opt in out source destination 0 0 RETURN tcp -- any any anywhere anywhere tcp dpt:15008 0 0 RETURN tcp -- any any anywhere anywhere tcp dpt:15090 27799 1668K RETURN tcp -- any any anywhere anywhere tcp dpt:15021 6 360 RETURN tcp -- any any anywhere anywhere tcp dpt:15020 0 0 ISTIO_IN_REDIRECT tcp -- any any anywhere anywhere # ISTIO_IN_REDIRECT 链：将所有的入站流量跳转到本地的 15006 端口，至此成功的拦截了流量到 Envoy Chain ISTIO_IN_REDIRECT (3 references) pkts bytes target prot opt in out source destination 0 0 REDIRECT tcp -- any any anywhere anywhere redir ports 15006 # ISTIO_OUTPUT 链：选择需要重定向到 Envoy（即本地） 的出站流量，所有非 localhost 的流量全部转发到 ISTIO_REDIRECT。为了避免流量在该 Pod 中无限循环，所有到 istio-proxy 用户空间的流量都返回到它的调用点中的下一条规则，本例中即 OUTPUT 链，因为跳出 ISTIO_OUTPUT 规则之后就进入下一条链 POSTROUTING。如果目的地非 localhost 就跳转到 ISTIO_REDIRECT；如果流量是来自 istio-proxy 用户空间的，那么就跳出该链，返回它的调用链继续执行下一条规则（OUPT 的下一条规则，无需对流量进行处理）；所有的非 istio-proxy 用户空间的目的地是 localhost 的流量就跳转到 ISTIO_REDIRECT Chain ISTIO_OUTPUT (1 references) pkts bytes target prot opt in out source destination 0 0 RETURN all -- any lo 127.0.0.6 anywhere 0 0 ISTIO_IN_REDIRECT all -- any lo anywhere !localhost owner UID match 1337 0 0 RETURN all -- any lo anywhere anywhere ! owner UID match 1337 50 3000 RETURN all -- any any anywhere anywhere owner UID match 1337 0 0 ISTIO_IN_REDIRECT all -- any lo anywhere !localhost owner GID match 1337 0 0 RETURN all -- any lo anywhere anywhere ! owner GID match 1337 0 0 RETURN all -- any any anywhere anywhere owner GID match 1337 0 0 RETURN all -- any any anywhere localhost 0 0 ISTIO_REDIRECT all -- any any anywhere anywhere # ISTIO_REDIRECT 链：将所有流量重定向到 Envoy（即本地） 的 15001 端口 Chain ISTIO_REDIRECT (1 references) pkts bytes target prot opt in out source destination 0 0 REDIRECT tcp -- any any anywhere anywhere redir ports 15001 Istio 如何实现自动注入Sidercar k label ns lin-test istio-injection=enabled k get mutatingwebhookconfigurations.admissionregistration.k8s.io istio-revision-tag-default -o yaml Sidecar 注入主要是依托k8s的准入控制器Admission Controller来实现的。\n可以定义两种类型的 Admission webhook：Validating 和 Mutating。\nValidating 类型的 Webhook 可以根据自定义的准入策略决定是否拒绝请求； Mutating 类型的 Webhook 可以根据自定义配置来对请求进行编辑。\nkubectl get mutatingwebhookconfiguration istio-sidecar-injector -o yaml 附 iptables istio-iptables -p PORT -u UID -g GID [-m mode] [-b ports] [-d ports] [-i CIDR] [-x CIDR] [-h] -p: 指定重定向所有 TCP 流量的 Envoy 端口（默认为 $ENVOY_PORT = 15001） -u: 指定未应用重定向的用户的 UID。通常，这是代理容器的 UID（默认为 $ENVOY_USER 的 uid，istio_proxy 的 uid 或 1337） -g: 指定未应用重定向的用户的 GID。（与 -u param 相同的默认值） -m: 指定入站连接重定向到 Envoy 的模式，“REDIRECT” 或 “TPROXY”（默认为 $ISTIO_INBOUND_INTERCEPTION_MODE) -b: 逗号分隔的入站端口列表，其流量将重定向到 Envoy（可选）。使用通配符 “*” 表示重定向所有端口。为空时表示禁用所有入站重定向（默认为 $ISTIO_INBOUND_PORTS） -d: 指定要从重定向到 Envoy 中排除（可选）的入站端口列表，以逗号格式分隔。使用通配符“*” 表示重定向所有入站流量（默认为 $ISTIO_LOCAL_EXCLUDE_PORTS） -i: 指定重定向到 Envoy（可选）的 IP 地址范围，以逗号分隔的 CIDR 格式列表。使用通配符 “*” 表示重定向所有出站流量。空列表将禁用所有出站重定向（默认为 $ISTIO_SERVICE_CIDR） -x: 指定将从重定向中排除的 IP 地址范围，以逗号分隔的 CIDR 格式列表。使用通配符 “*” 表示重定向所有出站流量（默认为 $ISTIO_SERVICE_EXCLUDE_CIDR）。 -z: 所有入站 TCP 流量重定向端口（默认为 $INBOUND_CAPTURE_PORT 15006） ","description":"Table of Contents\nsidercar Sidecar 注入实例分析 istio-init istio-proxy Istio 如何实现自动注入Sidercar 附 iptables sidercar Sidecar 注入实例分析 istio-init：用于给 Sidecar 容器即 Envoy 代理做初始化，设置 iptables 端口转发 istio-proxy：Envoy 代理容器，运行 Envoy 代理 istio-init # istio-init container yaml initContainers: - name: istio-init image: docker.io/istio/proxyv2:1.13.1 args: - istio-iptables - \u0026#39;-p\u0026#39; - \u0026#39;15001\u0026#39; - \u0026#39;-z\u0026#39; - \u0026#39;15006\u0026#39; - \u0026#39;-u\u0026#39; - \u0026#39;1337\u0026#39; - \u0026#39;-m\u0026#39; - REDIRECT - \u0026#39;-i\u0026#39; - \u0026#39;*\u0026#39; - \u0026#39;-x\u0026#39; - \u0026#39;\u0026#39; - \u0026#39;-b\u0026#39; - \u0026#39;*\u0026#39; - \u0026#39;-d\u0026#39; - 15090,15021,15020 该容器存在的意义就是让 Envoy 代理可以拦截所有的进出 Pod 的流量，即将入站流量重定向到 Sidecar，再拦截应用容器的出站流量经过 Sidecar 处理后再出站。"},{"id":7,"href":"/istio/","title":"Istio","parent":"lin Blog Site","content":"","description":""},{"id":8,"href":"/","title":"lin Blog Site","parent":"","content":"","description":""},{"id":9,"href":"/aws/","title":"AWS","parent":"lin Blog Site","content":"","description":""},{"id":10,"href":"/AWS/VPC/","title":"VPC","parent":"AWS","content":" Amazon VPC 是什么 通过 Amazon Virtual Private Cloud (Amazon VPC)，可以将 AWS 资源启动到定义的虚拟网络中。这个虚拟网络与在数据中心中运行的传统网络极其相似，并会提供使用的可扩展基础设施的优势\n功能 Virtual Private Cloud (VPC)：VPC 是一个虚拟网络，与您在自己的数据中心中运行的传统网络极为相似。创建 VPC 后，您可以添加子网。 子网： 子网是您的 VPC 内的 IP 地址范围。子网必须位于单个可用区中。在添加子网后，您可以在 VPC 中部署 AWS 资源。 IP 寻址： 您可以将 IPv4 地址和 IPv6 地址分配到 VPC 和子网。您还可以将您的公有 IPv4 和 IPv6 GUA 地址带到 AWS 并将其分配到 VPC 中的资源，例如 EC2 实例、NAT 网关和网络负载均衡器。 路由：使用路由表决定将来自您的子网或网关的网络流量定向到何处。 网关和端点：网关将您的 VPC 连到其他网络。例如，使用互联网网关将您的 VPC 连接到网络。使用 VPC 端点私下连接到 AWS 服务，无需使用互联网网关或 NAT 设备。 对等连接：使用 VPC 对等连接在两个 VPC 中的资源之间路由流量。 流量镜像：从网络接口复制网络流量，然后将其发送到安全和监控设备进行深度数据包检查。 中转网关：将中转网关用作中央枢纽，以在 VPC、VPN 连接和 AWS Direct Connect 连接之间路由流量。 VPC 流日志：流日志捕获有关在 VPC 中传入和传出网络接口的 IP 流量的信息。 VPN 连接：使用 AWS Virtual Private Network (AWS VPN) 将 VPC 连接到您的本地网络。 ","description":" Amazon VPC 是什么 通过 Amazon Virtual Private Cloud (Amazon VPC)，可以将 AWS 资源启动到定义的虚拟网络中。这个虚拟网络与在数据中心中运行的传统网络极其相似，并会提供使用的可扩展基础设施的优势\n功能 Virtual Private Cloud (VPC)：VPC 是一个虚拟网络，与您在自己的数据中心中运行的传统网络极为相似。创建 VPC 后，您可以添加子网。 子网： 子网是您的 VPC 内的 IP 地址范围。子网必须位于单个可用区中。在添加子网后，您可以在 VPC 中部署 AWS 资源。 IP 寻址： 您可以将 IPv4 地址和 IPv6 地址分配到 VPC 和子网。您还可以将您的公有 IPv4 和 IPv6 GUA 地址带到 AWS 并将其分配到 VPC 中的资源，例如 EC2 实例、NAT 网关和网络负载均衡器。 路由：使用路由表决定将来自您的子网或网关的网络流量定向到何处。 网关和端点：网关将您的 VPC 连到其他网络。例如，使用互联网网关将您的 VPC 连接到网络。使用 VPC 端点私下连接到 AWS 服务，无需使用互联网网关或 NAT 设备。 对等连接：使用 VPC 对等连接在两个 VPC 中的资源之间路由流量。 流量镜像：从网络接口复制网络流量，然后将其发送到安全和监控设备进行深度数据包检查。 中转网关：将中转网关用作中央枢纽，以在 VPC、VPN 连接和 AWS Direct Connect 连接之间路由流量。 VPC 流日志：流日志捕获有关在 VPC 中传入和传出网络接口的 IP 流量的信息。 VPN 连接：使用 AWS Virtual Private Network (AWS VPN) 将 VPC 连接到您的本地网络。 "},{"id":11,"href":"/AWS/Organizations/","title":"AWS Organizations","parent":"AWS","content":"","description":""},{"id":12,"href":"/AWS/IAM/","title":"IAM","parent":"AWS","content":" 什么是IAM AWS Identity and Access Management (IAM) 是一种 Web 服务，可以安全地控制对AWS资源的访问。\nAWS 账户根用户是创建AWS 账户时创建的。建议不要使用跟用户执行日常AWS操作\nIAM 功能 可多人共享操作AWS 资源，创建单独的IAM role可以不必共享自己的登陆信息 精细权限管理 可以针对不同资源向不同人员授予不同权限 给Amazon EC2上运行的应用程序提供AWS资源的安全访问权限 多重身份验证（MFA） 可以给账户天假双重身份验证，以实现更高安全性。 联合登陆（联合身份） 可以允许在其他用户管理系统中提供的用户获取AWS账户的临时访问权限 身份信息可在AWS CloudTrail中记录 如果使用AWS CLoudTrail，则会收到对资源进行请求的人员信息 \u0026hellip; 使用IAM操作AWS资源 AWS Management Console 页面登录 AWS CLI操作 首先需要登陆AWS，使用aws configure, 参考链接 术语 IAM 资源： 存储在 IAM 中的用户、组、角色、策略和身份提供商对象。与其他 AWS 服务一样，可以在 IAM 中添加、编辑和删除资源。 IAM 身份： 用于标识和分组的 IAM 资源对象。可以将策略附加到 IAM 身份。其中包括用户、组和角色。 IAM 实体： AWS 用于进行身份验证的 IAM 资源对象。其中包括 IAM 用户和角色。 主体： 可请求对 AWS 资源执行操作的人员或应用程序。 IAM 中的权限和策略 IAM 用户是服务中的身份。当创建 IAM 用户时，他们无法访问账户中的任何资源，需要给他们授予权限。向用户授予权限的方法是创建基于身份的策略，附加到用户或用户所属组的策略。\nJSON策略案例：\n// 该策略允许用户对 us-east-2 区域内的 123456789012 账户中的 Books 表执行所有 Amazon DynamoDB 操作 (dynamodb:*)。 { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;dynamodb:*\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:dynamodb:us-east-2:123456789012:table/Books\u0026#34; } } 策略和组 可以将 IAM 用户组织为 IAM 组，然后将策略附加到组。这种情况下，各用户仍有自己的凭证，但是组中的所有用户都具有附加到组的权限。使用组可更轻松地管理权限， 可参考IAM中的安全最佳实践\n参考文档\n","description":"什么是IAM AWS Identity and Access Management (IAM) 是一种 Web 服务，可以安全地控制对AWS资源的访问。\nAWS 账户根用户是创建AWS 账户时创建的。建议不要使用跟用户执行日常AWS操作\nIAM 功能 可多人共享操作AWS 资源，创建单独的IAM role可以不必共享自己的登陆信息 精细权限管理 可以针对不同资源向不同人员授予不同权限 给Amazon EC2上运行的应用程序提供AWS资源的安全访问权限 多重身份验证（MFA） 可以给账户天假双重身份验证，以实现更高安全性。 联合登陆（联合身份） 可以允许在其他用户管理系统中提供的用户获取AWS账户的临时访问权限 身份信息可在AWS CloudTrail中记录 如果使用AWS CLoudTrail，则会收到对资源进行请求的人员信息 \u0026hellip; 使用IAM操作AWS资源 AWS Management Console 页面登录 AWS CLI操作 首先需要登陆AWS，使用aws configure, 参考链接 术语 IAM 资源： 存储在 IAM 中的用户、组、角色、策略和身份提供商对象。与其他 AWS 服务一样，可以在 IAM 中添加、编辑和删除资源。 IAM 身份： 用于标识和分组的 IAM 资源对象。可以将策略附加到 IAM 身份。其中包括用户、组和角色。 IAM 实体： AWS 用于进行身份验证的 IAM 资源对象。其中包括 IAM 用户和角色。 主体： 可请求对 AWS 资源执行操作的人员或应用程序。 IAM 中的权限和策略 IAM 用户是服务中的身份。当创建 IAM 用户时，他们无法访问账户中的任何资源，需要给他们授予权限。向用户授予权限的方法是创建基于身份的策略，附加到用户或用户所属组的策略。"},{"id":13,"href":"/tags/","title":"Tags","parent":"lin Blog Site","content":"","description":""}]